import json
import urllib.error
import urllib.request

MCP_ENDPOINT = __MCP_ENDPOINT__


class _ToolsNamespace:
    def __init__(self, endpoint):
        self._endpoint = endpoint
        self._call_id = 0

    def _call(self, name, **kwargs):
        self._call_id += 1
        payload = {
            "jsonrpc": "2.0",
            "id": f"python-runner-{self._call_id}",
            "method": "tools/call",
            "params": {
                "name": name,
                "arguments": kwargs,
            },
        }

        data = json.dumps(payload).encode("utf-8")
        request = urllib.request.Request(
            self._endpoint,
            data=data,
            headers={"Content-Type": "application/json"},
            method="POST",
        )

        try:
            with urllib.request.urlopen(request, timeout=60) as response:
                response_data = response.read().decode("utf-8")
        except urllib.error.HTTPError as exc:
            body = exc.read().decode("utf-8", errors="ignore")
            raise RuntimeError(
                f"MCP HTTP error calling {name}: {exc.code} {body}"
            ) from exc
        except urllib.error.URLError as exc:
            raise RuntimeError(
                f"Failed to reach MCP endpoint for {name}: {exc}"
            ) from exc

        message = json.loads(response_data)
        if message.get("error"):
            err = message["error"]
            raise RuntimeError(
                f"MCP error calling {name}: {err.get('message')} (code {err.get('code')})"
            )

        result = message.get("result") or {}
        content = result.get("content") if isinstance(result, dict) else None
        if isinstance(content, list):
            texts = [
                item.get("text", "")
                for item in content
                if item.get("type") == "text"
            ]
            if len(texts) == 1:
                return texts[0]
            if texts:
                return "\n".join(texts)
        return result


tools = _ToolsNamespace(MCP_ENDPOINT)


def _wrap_tool(name):
    def _inner(**kwargs):
        return tools._call(name, **kwargs)

    _inner.__name__ = name
    return _inner


__TOOL_TRAMPOLINES__
